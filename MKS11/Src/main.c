/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

//ignore
#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{
    /* Loop forever */
	for(;;);
}

//My attempt
#include "main.h"

#include "rfm95.h"
#include <stdio.h>
#include <string.h>

extern SPI_HandleTypeDef hspi3;
extern TIM_HandleTypeDef htim2;
extern RNG_HandleTypeDef hrng;

#define MSG_TIME 10000
#define BTN_TIME 3000

uint32_t get_precision_tick(void)
{
    return __HAL_TIM_GET_COUNTER(&htim2);
}

void precision_sleep_until(uint32_t target_ticks)
{
    while (get_precision_tick() < target_ticks)
    {
        /* busy wait */
    }
}

uint8_t random_int(uint8_t max)
{
    uint32_t rng;
    HAL_RNG_GenerateRandomNumber(&hrng, &rng);
    return (uint8_t)(rng % (max + 1));
}


rfm95_handle_t rfm95_handle =
{
    .spi_handle = &hspi3,

    .nss_port = RFM95_NSS_GPIO_Port,
    .nss_pin  = RFM95_NSS_Pin,

    .device_address = {
        0x26, 0x0B, 0x04, 0xXX
    },

    .application_session_key = {
        0x40, 0x0A, 0xE6, 0x65,
        0x1A, 0xA8, 0x92, 0x92,
        0x12, 0xC0, 0x08, 0xEC,
        0xC2, 0xC1, 0x53, 0x72
    },

    .network_session_key = {
        0x80, 0x70, 0x52, 0xDA,
        0x22, 0x5F, 0x54, 0xC3,
        0xB8, 0xDC, 0xAD, 0xA1,
        0x8A, 0xF2, 0x85, 0x34
    },

    .receive_mode = RFM95_RECEIVE_MODE_NONE,
    .precision_tick_frequency = 20000,

    .get_precision_tick = get_precision_tick,
    .precision_sleep_until = precision_sleep_until,
    .random_int = random_int
};


void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    rfm95_handle_interrupt(&rfm95_handle, GPIO_Pin);
}

HAL_TIM_Base_Start(&htim2);

if (!rfm95_init(&rfm95_handle))
{
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_SET); // LD3 RED
    while (1);
}

uint32_t last_send_tick = 0;
uint32_t block_until_tick = 0;
uint32_t counter = 0;

char tx_buffer[64];

while (1)
{
    uint32_t now = get_precision_tick();

    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET)
    {
        if (now > block_until_tick)
        {
            sprintf(tx_buffer, "vutid;press");

            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_SET);
            rfm95_send_receive_cycle(
                &rfm95_handle,
                (uint8_t *)tx_buffer,
                strlen(tx_buffer)
            );
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_RESET);

            block_until_tick = now + (5 * 20000);
        }
    }

    if ((now - last_send_tick) > (30 * 20000) && now > block_until_tick)
    {
        sprintf(tx_buffer, "vutid;%lu", counter++);

        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_SET);
        rfm95_send_receive_cycle(
            &rfm95_handle,
            (uint8_t *)tx_buffer,
            strlen(tx_buffer)
        );
        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_RESET);

        last_send_tick = now;
    }
}
